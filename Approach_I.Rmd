---
title: "Approach I"
author: "Astha Bista"
date: "2/9/2021"
output: html_document
---
```{r echo=FALSE,include=FALSE, warning=FALSE}
setwd("C:/Users/Aastha/Desktop/GWProject")
list.of.packages <- c("tseries","FactoMineR","factoextra","rela","psych","corrplot")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
library("FactoMineR")
library("factoextra")
library(rela)
library(psych)
library(corrplot)
library(tseries)

## First, here is a function to plot many time series using ggplot
## We will be using this function in the following lines
## Plot the stationary time series

create_timeseries_plots <- function(df){
  # change into metres
  df <- sapply(as.data.frame(df), function(y) y*0.3048)
  # column with dates
  dates = seq(from = as.Date("2000-02-01"), to = as.Date("2018-12-1"), by = 'month') 
  # add date column to dataframe
  df_m <- data.frame(as.data.frame(df[,-1]),dates)
  colnames(df_m)[ncol(df_m)]<-"Date"
  library(reshape2)
  library(ggplot2)
  library(dplyr)
  # Rearrange dataframe to long form
  df_m2 <- melt(df_m, id.vars = "Date", 
                variable.name = "Var", value.name="Val")
  # Group the dataframe
  df_m3 <- df_m2%>%
    group_by(Date,Var)
  #Plot using ggplot2
  ggplot(data = df_m3,aes(x = Date, y = Val)) + 
    geom_line() + facet_wrap(~ Var, nrow = 6, scales = "free") +
    xlab("Year") + ylab("Units(m)") + theme_bw()
}

```

# Converting time series to stationary
In this approach, the time series data is made stationary using first differencing methods. For testing stationarity, Augmented Dickey-Fuller (ADF) t-statistic test for unit root was used.

```{r echo=FALSE,warning=FALSE}
GWData<-read.csv(file ="Data_Processing/GWLevel_imputed.csv",header = TRUE)  
head(GWData)
```
Now, loop around each column in the dataframe to obtain a dataframe containing first degree differenced values.

```{r echo=FALSE,warning=FALSE,include=FALSE}
diff_gw<-c()
for(i in 2:13){               #Loop around 13 wells groundwater levels
  diff_dat<-diff(GWData[,i])    #First degree differencing
  diff_gw<-cbind(diff_gw,diff_dat)
}

colnames(diff_gw)<-c("W60","W63","W67","W70","W73","W74","W78","W80","W81","W115","W116","W118")

# Check stationarity of each column in new dataframe using Augmented Dickey-Fuller (ADF) 
# t-statistic test for unit root. If H0 is rejected, the series is stationary
for(i in 1:12){ 
  print(adf.test(diff_gw[,i])$p.value)  #Alternate hypotheisis: stationary
}
```
This above procedure were also used to create stationary time series of stream stage, precipitation, and pumping.
Below is the plot showing the stationary time series. Please note that the units are differences of water levels between a month and preceding month, therefore the negative values in some cases.
```{r  fig.height=10,fig.width=10,echo = FALSE, warning=FALSE}
create_timeseries_plots(diff_gw)
```

# Principal Component Analysis

### Check suitability of PCA
```{r echo=FALSE}
#First compute correlation matrix
GWDataCor <- cor(GWData)
```

We now examine the data to assess whether the assumptions for PCA have been met before proceeding. We use the paf() function from the rela package.
```{r echo=FALSE, include=FALSE}
assumptions <- paf(as.matrix(GWData), eigcrit = 1, convcrit = .001)
```

To test for the first assumption, Bartlett’s Test for Sphericity was performed. The null hypothesis for this test is that the intercorrelation matrix comes from a noncollinear populaton or simply that there is nocollinearity between the variables, which would render PCA impossible as it depends on the construction of a linear combination of the variables. We use a significance level α=.05.(----------cite)
```{r ,warning=FALSE}
bartlettTest <- cortest.bartlett(GWDataCor)
bartlettTest
```

Bartlett test is rejected because p values is less than 0.01. Now we will extract Kaiser-Meyer-Olkin (KMO) from the assumptions object.
```{r echo=FALSE}
print(assumptions$KMO)
```

This value is more than 0.7, so can be acceptable. 
```{r}
det(GWDataCor)
```
The determinant is positive, hence it satisfies all three assumptions of PCA. Therefore, we can proceed with PCA.

### Analyzing correlation matrix
The correlation matrix is shown graphically. This following plot gives a prelimminary insight on the relationship between the groundwater levels in wells.
```{r, echo=FALSE}
cor.mat <- round(cor(GWData),2)
corrplot(cor.mat, type="upper", order="hclust", 
         tl.col="black", tl.srt=45)
```

### Performing PCA
The data is first standardized by centering and scaling.
```{r}
GWData<-scale(GWData)
```
Now, FactoMine package is used to perform PCA.
```{r}
res.pca <- PCA(GWData, graph = F)
```
```{r echo=FALSE}
eigenvalues <- res.pca$eig
barplot(eigenvalues[, 2], names.arg=1:nrow(eigenvalues), 
        main = "Variances",
        xlab = "Principal Components",
        ylab = "Percentage of variances",
        col ="steelblue")
lines(x = 1:nrow(eigenvalues), eigenvalues[, 2], 
      type="b", pch=19, col = "red")
```

The above screeplot shows that three components are dominant in the data. Therefore, we will use three principal components. The variables can also be shown in a base graph showing contribution levels of each well along with information on the alignment of each well on principal components.
```{r echo=FALSE}
fviz_pca_var(res.pca, col.var="contrib")+ 
  scale_color_gradient2(low="white",mid="blue",high="red", midpoint=2.5)+theme_bw()
```

### Output
The main output of PCA are PC scores and PC loadings.
```{r echo=FALSE}
loadings<-sweep(res.pca$var$coord,2,sqrt(res.pca$eig[1:ncol(res.pca$var$coord),1]),FUN="/")
scores <- res.pca$ind$coord
```
Loadings:
```{r echo=FALSE}
head(loadings)
```
Scores:
```{r echo=FALSE}
head(scores)
```


